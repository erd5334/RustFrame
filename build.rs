use std::fs;
use std::path::{Path, PathBuf};

fn main() {
    // Read version from Cargo.toml for Windows EXE metadata
    // This ensures the version input from GitHub Actions is used
    let version = std::env::var("CARGO_PKG_VERSION").unwrap_or_else(|_| "0.0.0".to_string());
    println!("cargo:rustc-env=RUSTFRAME_VERSION={}", version);

    // Only initialize Tauri build when the app feature is enabled.
    if std::env::var("CARGO_FEATURE_APP").is_ok() {
        tauri_build::build();
    }

    // Build scripts should not write into a user's runtime config directory.
    // Instead, we stage platform-specific defaults into OUT_DIR and embed them at compile time.
    stage_platform_resources_into_out_dir();

    println!("cargo:rerun-if-changed=resources/");
}

fn stage_platform_resources_into_out_dir() {
    let manifest_dir = std::env::var("CARGO_MANIFEST_DIR").unwrap();
    let out_dir = PathBuf::from(std::env::var("OUT_DIR").unwrap());

    let target_os = std::env::var("CARGO_CFG_TARGET_OS").unwrap_or_else(|_| "unknown".to_string());
    let resources_src = Path::new(&manifest_dir).join("resources");

    // ---- Default settings ----
    let default_settings_src = resources_src
        .join("default_settings")
        .join(format!("{}.json", target_os));
    let default_settings_dst = out_dir.join("rustframe_default_settings.json");

    if default_settings_src.exists() {
        if let Err(e) = fs::copy(&default_settings_src, &default_settings_dst) {
            println!(
                "cargo:warning=Failed to stage default settings {:?} -> {:?}: {}",
                default_settings_src, default_settings_dst, e
            );
        }
    } else {
        println!(
            "cargo:warning=Missing platform default settings at {:?} (target_os={})",
            default_settings_src, target_os
        );
        // Ensure file exists so include_str doesn't fail.
        let _ = fs::write(&default_settings_dst, "{}");
    }

    // ---- Profiles ----
    let profiles_src = resources_src.join("profiles").join(&target_os);
    let profiles_out_dir = out_dir.join("rustframe_profiles");
    let _ = fs::create_dir_all(&profiles_out_dir);

    let mut staged_profiles: Vec<String> = Vec::new();
    if profiles_src.exists() {
        if let Ok(entries) = fs::read_dir(&profiles_src) {
            for entry in entries.flatten() {
                let path = entry.path();
                if path.is_dir() {
                    continue;
                }
                if path.extension().and_then(|e| e.to_str()) != Some("json") {
                    continue;
                }
                let Some(file_name) = path.file_name().and_then(|n| n.to_str()) else {
                    continue;
                };
                let dst = profiles_out_dir.join(file_name);
                if fs::copy(&path, &dst).is_ok() {
                    staged_profiles.push(file_name.to_string());
                }
            }
        }
    }

    // Generate a Rust source file listing the staged profiles.
    // This keeps platform selection purely build-time.
    let generated_rs = out_dir.join("rustframe_bundled_profiles.rs");
    let mut src = String::new();
    src.push_str("// @generated by build.rs\n");
    src.push_str("pub const PROFILES: &[(&'static str, &'static str)] = &[\n");
    for file_name in staged_profiles {
        // Use OUT_DIR absolute paths; include_str requires a string literal.
        let abs_path = profiles_out_dir.join(&file_name);
        let abs_path_str = abs_path.to_string_lossy().replace('\\', "\\\\");
        src.push_str(&format!(
            "    (\"{}\", include_str!(\"{}\")),\n",
            file_name, abs_path_str
        ));
    }
    src.push_str("];\n");

    if let Err(e) = fs::write(&generated_rs, src) {
        println!(
            "cargo:warning=Failed to write generated bundled profiles file {:?}: {}",
            generated_rs, e
        );
    }
}
